// Standard includes
#include "pebble.h"

#define TOTAL_IMAGE_SLOTS 4

#define NUMBER_OF_IMAGES 10

#define NUMBER_OF_STYLES 9

#define GEN_MODE 1
#define GEN_STYLE 2

// These images are 56 x 62 pixels (i.e. a quarter of the display),
// black and white with the digit character centered in the image.
// (As generated by the `fonttools/font2png.py` script.)
const int IMAGE_RESOURCE_IDS[NUMBER_OF_STYLES][NUMBER_OF_IMAGES] = {
    {
      RESOURCE_ID_IMAGE_NUM_A_0, RESOURCE_ID_IMAGE_NUM_A_1, RESOURCE_ID_IMAGE_NUM_A_2,
      RESOURCE_ID_IMAGE_NUM_A_3, RESOURCE_ID_IMAGE_NUM_A_4, RESOURCE_ID_IMAGE_NUM_A_5,
      RESOURCE_ID_IMAGE_NUM_A_6, RESOURCE_ID_IMAGE_NUM_A_7, RESOURCE_ID_IMAGE_NUM_A_8,
      RESOURCE_ID_IMAGE_NUM_A_9
    },
    {
      RESOURCE_ID_IMAGE_NUM_B_0, RESOURCE_ID_IMAGE_NUM_B_1, RESOURCE_ID_IMAGE_NUM_B_2,
      RESOURCE_ID_IMAGE_NUM_B_3, RESOURCE_ID_IMAGE_NUM_B_4, RESOURCE_ID_IMAGE_NUM_B_5,
      RESOURCE_ID_IMAGE_NUM_B_6, RESOURCE_ID_IMAGE_NUM_B_7, RESOURCE_ID_IMAGE_NUM_B_8,
      RESOURCE_ID_IMAGE_NUM_B_9
    },
    {
      RESOURCE_ID_IMAGE_NUM_C_0, RESOURCE_ID_IMAGE_NUM_C_1, RESOURCE_ID_IMAGE_NUM_C_2,
      RESOURCE_ID_IMAGE_NUM_C_3, RESOURCE_ID_IMAGE_NUM_C_4, RESOURCE_ID_IMAGE_NUM_C_5,
      RESOURCE_ID_IMAGE_NUM_C_6, RESOURCE_ID_IMAGE_NUM_C_7, RESOURCE_ID_IMAGE_NUM_C_8,
      RESOURCE_ID_IMAGE_NUM_C_9
    },
    {
      RESOURCE_ID_IMAGE_NUM_D_0, RESOURCE_ID_IMAGE_NUM_D_1, RESOURCE_ID_IMAGE_NUM_D_2,
      RESOURCE_ID_IMAGE_NUM_D_3, RESOURCE_ID_IMAGE_NUM_D_4, RESOURCE_ID_IMAGE_NUM_D_5,
      RESOURCE_ID_IMAGE_NUM_D_6, RESOURCE_ID_IMAGE_NUM_D_7, RESOURCE_ID_IMAGE_NUM_D_8,
      RESOURCE_ID_IMAGE_NUM_D_9
    },
    {
      RESOURCE_ID_IMAGE_NUM_E_0, RESOURCE_ID_IMAGE_NUM_E_1, RESOURCE_ID_IMAGE_NUM_E_2,
      RESOURCE_ID_IMAGE_NUM_E_3, RESOURCE_ID_IMAGE_NUM_E_4, RESOURCE_ID_IMAGE_NUM_E_5,
      RESOURCE_ID_IMAGE_NUM_E_6, RESOURCE_ID_IMAGE_NUM_E_7, RESOURCE_ID_IMAGE_NUM_E_8,
      RESOURCE_ID_IMAGE_NUM_E_9
    },
    {
      RESOURCE_ID_IMAGE_NUM_F_0, RESOURCE_ID_IMAGE_NUM_F_1, RESOURCE_ID_IMAGE_NUM_F_2,
      RESOURCE_ID_IMAGE_NUM_F_3, RESOURCE_ID_IMAGE_NUM_F_4, RESOURCE_ID_IMAGE_NUM_F_5,
      RESOURCE_ID_IMAGE_NUM_F_6, RESOURCE_ID_IMAGE_NUM_F_7, RESOURCE_ID_IMAGE_NUM_F_8,
      RESOURCE_ID_IMAGE_NUM_F_9
    },
    {
      RESOURCE_ID_IMAGE_NUM_G_0, RESOURCE_ID_IMAGE_NUM_G_1, RESOURCE_ID_IMAGE_NUM_G_2,
      RESOURCE_ID_IMAGE_NUM_G_3, RESOURCE_ID_IMAGE_NUM_G_4, RESOURCE_ID_IMAGE_NUM_G_5,
      RESOURCE_ID_IMAGE_NUM_G_6, RESOURCE_ID_IMAGE_NUM_G_7, RESOURCE_ID_IMAGE_NUM_G_8,
      RESOURCE_ID_IMAGE_NUM_G_9
    },
    {
      RESOURCE_ID_IMAGE_NUM_H_0, RESOURCE_ID_IMAGE_NUM_H_1, RESOURCE_ID_IMAGE_NUM_H_2,
      RESOURCE_ID_IMAGE_NUM_H_3, RESOURCE_ID_IMAGE_NUM_H_4, RESOURCE_ID_IMAGE_NUM_H_5,
      RESOURCE_ID_IMAGE_NUM_H_6, RESOURCE_ID_IMAGE_NUM_H_7, RESOURCE_ID_IMAGE_NUM_H_8,
      RESOURCE_ID_IMAGE_NUM_H_9
    },
    {
      RESOURCE_ID_IMAGE_NUM_I_0, RESOURCE_ID_IMAGE_NUM_I_1, RESOURCE_ID_IMAGE_NUM_I_2,
      RESOURCE_ID_IMAGE_NUM_I_3, RESOURCE_ID_IMAGE_NUM_I_4, RESOURCE_ID_IMAGE_NUM_I_5,
      RESOURCE_ID_IMAGE_NUM_I_6, RESOURCE_ID_IMAGE_NUM_I_7, RESOURCE_ID_IMAGE_NUM_I_8,
      RESOURCE_ID_IMAGE_NUM_I_9
    }
};

const int styles[NUMBER_OF_STYLES][2] = {
    { GColorWhite, GColorBlack },
    { GColorBlack, GColorWhite },
    { GColorWhite, GColorBlack },
    { GColorWhite, GColorBlack },
    { GColorBlack, GColorWhite },
    { GColorWhite, GColorBlack },
    { GColorBlack, GColorWhite },
    { GColorWhite, GColorBlack },
    { GColorWhite, GColorBlack }
};

const int FONTS[NUMBER_OF_STYLES] = {
  RESOURCE_ID_PURISA_12,
  RESOURCE_ID_LIBERATION_13,
  RESOURCE_ID_ROBOTO_BOLD_16,
  RESOURCE_ID_ROBOTO_BOLD_16,
  RESOURCE_ID_LIBERATION_13,
  RESOURCE_ID_ROBOTO_BOLD_16,
  RESOURCE_ID_ROBOTO_BOLD_16,
  RESOURCE_ID_LIBERATION_13,
  RESOURCE_ID_ROBOTO_BOLD_16
};

static GBitmap *numbers[NUMBER_OF_IMAGES];

static const char* const DOWS[] = {
  "DOMENICA", "LUNEDÌ", "MARTEDÌ", "MERCOLEDÌ", "GIOVEDÌ", "VENERDÌ", "SABATO" 
};

static const char* const DOWS_SHORT[] = {
  "DOM", "LUN", "MAR", "MER", "GIO", "VEN", "SAB" 
};

static const char* const MONTHS[] = {
  "GEN", "FEB", "MAR", "APR", "MAG", "GIU", "LUG", "AGO", "SET", "OTT", "NOV", "DIC" 
};

static const char* const ONES[] = {
  "ZERO", "UNO", "DUE", "TRE", "QUATTRO", "CINQUE", "SEI", "SETTE", "OTTO", "NOVE"
};

static const char* const TEENS[] = {
  "DIECI", "UNDICI", "DODICI", "TREDICI", "QUATTORDICI", "QUINDICI", "SEDICI", "DICIASSETTE", "DICIOTTO", "DICIANNOVE"
};

static const char* const TENS[] = {
  "VENTI", "TRENTA", "QUARANTA", "CINQUANTA"
};

static const int position[NUMBER_OF_IMAGES][2][2] ={
  {{16,12},{56,62}},
  {{72,12},{56,62}},
  {{16,80},{56,62}},
  {{72,80},{56,62}}
};

enum Modes {
    mode_text,
    mode_seconds,
    mode_seconds_dt,
    mode_seconds_st,
    mode_none
};

static void set_style(int style); 

static short int icDown = 0;
static short int current_style = -1;

static BitmapLayer *image_containers[TOTAL_IMAGE_SLOTS];

#define EMPTY_SLOT -1

static int image_slot_state[TOTAL_IMAGE_SLOTS] = {EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT};

// App-specific data
static Layer *window_layer;
static Window *window; // All apps must have at least one window
static TextLayer *status_layer;
static short int mode = mode_text;
static short int micro_mode = 0;
static char conn_text[10]    = "          ";
static char battery_text[10] = "          ";
static char date_text[24]    = "                        ";
static char dt_text[24]    = "                        ";
static char seconds[24]      = "                        ";

void update_seconds(char* res, int sec) {
    strcpy(res, "");
    if (sec < 10) {
        strcat(res, ONES[sec]);
        return;  
    }
    if (sec < 20) {
        strcat(res, TEENS[sec-10]);
        return;  
    }
    int ones_val = sec % 10; 
    int tens_val = sec / 10;
    
    strcpy(res, TENS[tens_val - 2]);
    if (ones_val == 1 || ones_val == 8) {
        res[strlen(res)-1] = '\0';
    }
    if (ones_val>0) strcat(res, ONES[ones_val]);
}
  
static void do_deinit(void) {
  tick_timer_service_unsubscribe();
  battery_state_service_unsubscribe();
  bluetooth_connection_service_unsubscribe();
  
  text_layer_destroy(status_layer);
  window_destroy(window);
  persist_write_int(GEN_STYLE, current_style);
  persist_write_int(GEN_MODE, mode);
}

static void handle_battery(BatteryChargeState charge_state) {
  if (charge_state.is_charging) {
    strcpy(battery_text, "IN CAR");
  } else {
    snprintf(battery_text, 4, "%d", charge_state.charge_percent);
    strcat(battery_text,"%");
  }
}

void load_digit_image_into_slot(int slot_number, int digit_value) {
  image_slot_state[slot_number] = digit_value;
  bitmap_layer_set_bitmap(image_containers[slot_number], numbers[digit_value]);
}

void display_value(unsigned short value, unsigned short row_number, bool show_first_leading_zero) {
  value = value % 100; // Maximum of two digits per row.

  for (int column_number = 1; column_number >= 0; column_number--) {
    int slot_number = (row_number * 2) + column_number;
    if (!((value == 0) && (column_number == 0) && !show_first_leading_zero)) {
      load_digit_image_into_slot(slot_number, value % 10);
    }
    value = value / 10;
  }
}

void int2str(int value, char* res) {
  char ten_val = 48;
  char one_val = 48;
  
  memset(res, 0, sizeof(res));
  
  if (value>=10) {
    one_val =  48 + (value % 10);
    value = value / 10;
    ten_val = 48 + value;
  } else {
    one_val = 48 + value;
  }
  res[0] = (char) ten_val;
  res[1] = (char) one_val;
  res[2] = '\0';
}

unsigned short get_display_hour(unsigned short hour) {

  if (clock_is_24h_style()) {
    return hour;
  }

  unsigned short display_hour = hour % 12;

  return display_hour ? display_hour : 12;
}

void update_date(struct tm *tick_time) {
  static char date_day[9] = "xxxxxxxxx";
  static char date_day_n[2] = "00";
  static char date_mon[9] = "yyy";
  
  strcpy(date_day, DOWS[tick_time->tm_wday]);
  int2str(tick_time->tm_mday,date_day_n);
  strcpy(date_mon, MONTHS[tick_time->tm_mon]);
  
  snprintf(date_text, 24, "%s %u %s", date_day, tick_time->tm_mday, date_mon);
  strcpy(date_day, DOWS_SHORT[tick_time->tm_wday]);
  snprintf(dt_text, 24, "%s %u %s", date_day, tick_time->tm_mday, date_mon);
}

static void handle_bluetooth(bool connected) {
  if (icDown>0) return;
  strcpy(conn_text, connected ? "CONN" : "DISC");
}

static void handle_second_tick(struct tm* tick_time, TimeUnits units_changed) {
  char sec[2] = "00";
  static int day_m = 40;
  
  if (icDown > 0) {
    icDown--;
    return;
  }
  
  if (icDown == 0) {
    icDown--;
    text_layer_set_text(status_layer, "");
    for (int slot_number = 0; slot_number < TOTAL_IMAGE_SLOTS; slot_number++) {
      if (mode == mode_none) {
        layer_set_frame(bitmap_layer_get_layer(image_containers[slot_number]), 
          GRect(position[slot_number][0][0], position[slot_number][0][1]+(6 * (1+ slot_number/2)), position[slot_number][1][0], position[slot_number][1][1]));
      } else {
        layer_set_frame(bitmap_layer_get_layer(image_containers[slot_number]), 
          GRect(position[slot_number][0][0], position[slot_number][0][1], position[slot_number][1][0], position[slot_number][1][1]));
      }
    }
  }
  if (day_m != tick_time->tm_mday) {
    day_m = tick_time->tm_mday;
    update_date(tick_time);
  }
  
  layer_set_hidden((Layer*) status_layer, false);
      
  switch (mode) {
    case mode_text:
      update_seconds(seconds, tick_time->tm_sec);
      text_layer_set_text(status_layer, seconds);
      break;
    case mode_seconds:
      int2str(tick_time->tm_sec, sec);
      text_layer_set_text(status_layer, sec);
      break;
    case mode_seconds_dt:
      int2str(tick_time->tm_sec, sec);
      strcpy(seconds, sec);
      strcat(seconds, " - ");
      strcat(seconds, dt_text);
      text_layer_set_text(status_layer, seconds);
      break;
    case mode_seconds_st:
      int2str(tick_time->tm_sec, sec);
      strcpy(seconds, sec);
      strcat(seconds, " - ");
      strcat(seconds, conn_text);
      strcat(seconds, " - ");
      strcat(seconds, battery_text);
      text_layer_set_text(status_layer, seconds);
      break;
    case mode_none:
      text_layer_set_text(status_layer, "");
      layer_set_hidden((Layer*) status_layer, true);
      break;
  }
  
  display_value(get_display_hour(tick_time->tm_hour), 0, true);
  display_value(tick_time->tm_min, 1, true);
  
  handle_battery(battery_state_service_peek());
}

static void up_click_handler(ClickRecognizerRef recognizer, void *context) {
  for (int slot_number = 0; slot_number < TOTAL_IMAGE_SLOTS; slot_number++) {
    layer_set_frame(bitmap_layer_get_layer(image_containers[slot_number]), 
      GRect(position[slot_number][0][0], position[slot_number][0][1], position[slot_number][1][0], position[slot_number][1][1]));
  }
  if (micro_mode == 1) {
    char tmp[] = "                      ";
    snprintf(tmp, 24, "BT:%s BATT:%s", conn_text, battery_text);
    text_layer_set_text(status_layer, tmp);
    micro_mode = 0;
  } else {
    text_layer_set_text(status_layer, date_text);
    micro_mode = 1;
  }
  icDown = 5;
}

static void down_click_handler(ClickRecognizerRef recognizer, void *context) {
  int style = current_style;
  
  if (style == -1) {
    style = 1;
  } else {
    style++;
  }
  if (style == NUMBER_OF_STYLES) style = 0;
  set_style(style);
  icDown = 0;
}

static void select_click_handler(ClickRecognizerRef recognizer, void *context) {
  char sec[2] = "00";
      
  icDown = 0;
  
  time_t now = time(NULL);
  struct tm *tick_time = localtime(&now);
  
  switch (mode) {
    case mode_text:
      int2str(tick_time->tm_sec, sec);
      text_layer_set_text(status_layer, sec);
      mode = mode_seconds;
      break;
    case mode_seconds:
      int2str(tick_time->tm_sec, sec);
      strcpy(seconds, sec);
      strcat(seconds, " - ");
      strcat(seconds, dt_text);
      text_layer_set_text(status_layer, seconds);
      mode = mode_seconds_dt;
      break;
    case mode_seconds_dt:
      int2str(tick_time->tm_sec, sec);
      strcpy(seconds, sec);
      strcat(seconds, " - ");
      strcat(seconds, conn_text);
      strcat(seconds, " - ");
      strcat(seconds, battery_text);
      text_layer_set_text(status_layer, seconds);
      mode = mode_seconds_st;
      break;
    case mode_seconds_st:
      text_layer_set_text(status_layer, "");
      for (int slot_number = 0; slot_number < TOTAL_IMAGE_SLOTS; slot_number++) {
        layer_set_frame(bitmap_layer_get_layer(image_containers[slot_number]), 
          GRect(position[slot_number][0][0], position[slot_number][0][1]+(6 * (1+ slot_number/2)), position[slot_number][1][0], position[slot_number][1][1]));
      }
      layer_set_hidden((Layer*) status_layer, true);
      mode = mode_none;
      break;
    case mode_none:
      for (int slot_number = 0; slot_number < TOTAL_IMAGE_SLOTS; slot_number++) {
        layer_set_frame(bitmap_layer_get_layer(image_containers[slot_number]), 
          GRect(position[slot_number][0][0], position[slot_number][0][1], position[slot_number][1][0], position[slot_number][1][1]));
      }
      layer_set_hidden((Layer*) status_layer, false);
      update_seconds(seconds, tick_time->tm_sec);
      text_layer_set_text(status_layer, seconds);
      mode = mode_text;
      break;
  }  
  
  persist_write_int(GEN_MODE, mode);
}

static void click_config_provider(void *context) {
  window_single_click_subscribe(BUTTON_ID_SELECT, select_click_handler);
  window_single_click_subscribe(BUTTON_ID_UP, up_click_handler);
  window_single_click_subscribe(BUTTON_ID_DOWN, down_click_handler);
  //window_single_click_subscribe(BUTTON_ID_BACK, back_click_handler);
}

static void set_style(int style) {
  for (int i = 0; i < NUMBER_OF_IMAGES; i++) {
      if (current_style >= 0) {
        gbitmap_destroy(numbers[i]);  
      }
      numbers[i] = gbitmap_create_with_resource(IMAGE_RESOURCE_IDS[style][i]);
  }
  
  window_set_background_color(window, styles[style][1]);
  text_layer_set_text_color(status_layer, styles[style][0]);
  text_layer_set_background_color(status_layer, styles[style][1]);
  text_layer_set_font(status_layer, fonts_load_custom_font(resource_get_handle(FONTS[style])));
    
  time_t now = time(NULL);
  struct tm *current_time = localtime(&now);
  handle_second_tick(current_time, SECOND_UNIT);
  
  current_style = style;
  
  persist_write_int(GEN_STYLE, current_style);
}

static void do_init(void) {
  window = window_create();
  window_set_fullscreen(window, true);
  window_set_click_config_provider(window, click_config_provider);
  
  window_stack_push(window, true);
  window_layer = window_get_root_layer(window);

  status_layer = text_layer_create(GRect(0, 148, 144, 30));
  text_layer_set_text_alignment(status_layer, GTextAlignmentCenter);
  text_layer_set_text(status_layer, "");

  for (int i = 0; i < NUMBER_OF_IMAGES; i++) {
    numbers[i] = gbitmap_create_with_resource(IMAGE_RESOURCE_IDS[0][i]);
  }
  
  for (int slot_number = 0; slot_number < TOTAL_IMAGE_SLOTS; slot_number++) {
    image_containers[slot_number] = bitmap_layer_create(
        GRect(position[slot_number][0][0], position[slot_number][0][1], position[slot_number][1][0], position[slot_number][1][1]));
    
    load_digit_image_into_slot(slot_number, slot_number+6);
    layer_add_child(window_layer, bitmap_layer_get_layer(image_containers[slot_number]));
  }

  if (persist_exists(GEN_MODE)) {
    mode = persist_read_int(GEN_MODE);
  }

  time_t now = time(NULL);
  struct tm *current_time = localtime(&now);
  handle_second_tick(current_time, SECOND_UNIT);
  handle_bluetooth(bluetooth_connection_service_peek());

  tick_timer_service_subscribe(SECOND_UNIT, &handle_second_tick);
  battery_state_service_subscribe(&handle_battery);
  bluetooth_connection_service_subscribe(&handle_bluetooth);

  layer_add_child(window_layer, text_layer_get_layer(status_layer));
  
  if (persist_exists(GEN_STYLE)) {
    set_style(persist_read_int(GEN_STYLE));
  } else {
    set_style(0);
  }
  
}

// The main event/run loop for our app
int main(void) {
  do_init();
  app_event_loop();
  do_deinit();
}
